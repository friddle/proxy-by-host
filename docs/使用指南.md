# Simple Proxy 使用指南

## 快速开始

### 1. 准备代理

首先，确保你有一个可用的代理服务（HTTP/HTTPS 或 SOCKS5）。常见的代理工具：
- Clash for Windows / ClashX（通常监听 `http://127.0.0.1:7890`）
- V2rayN（通常监听 `socks5://127.0.0.1:1080`）
- Shadowsocks

### 2. 配置并启动

**方式一：使用启动脚本（推荐）**

编辑 `启动示例.sh`，取消注释并设置你的代理：

```bash
# 如果你使用 Clash
export HTTP_PROXY=http://127.0.0.1:7890
export HTTPS_PROXY=http://127.0.0.1:7890

# 如果你使用 V2ray 的 SOCKS5
# export SOCKS_PROXY=socks5://127.0.0.1:1080
```

然后运行：
```bash
./启动示例.sh
```

**方式二：手动运行**

```bash
# 设置环境变量
export UPSTREAM_HOST=47.252.16.154
export HTTP_PROXY=http://127.0.0.1:7890
export HTTPS_PROXY=http://127.0.0.1:7890

# 编译并运行
go build -o simple-proxy main.go
./simple-proxy
```

**方式三：直接运行（无需编译）**

```bash
export UPSTREAM_HOST=47.252.16.154
export HTTP_PROXY=http://127.0.0.1:7890
export HTTPS_PROXY=http://127.0.0.1:7890

go run main.go
```

### 3. 测试

启动服务后，在另一个终端测试：

```bash
# 测试 1: 使用 Host 头
curl -H "Host: webmail.prod.code27.cn" http://localhost:8080/

# 测试 2: 如果你配置了 hosts 文件
curl http://webmail.prod.code27.cn:8080/

# 测试 3: 查看详细信息
curl -v -H "Host: xxx.code27.cn" http://localhost:8080/api/status
```

## 实际使用场景

### 场景 1: 浏览器访问

1. 修改系统 hosts 文件（需要管理员权限）：

**macOS/Linux:**
```bash
sudo vim /etc/hosts
```

**Windows:**
```
用管理员权限编辑 C:\Windows\System32\drivers\etc\hosts
```

添加：
```
127.0.0.1 webmail.prod.code27.cn
127.0.0.1 xxx.code27.cn
127.0.0.1 yyy.code27.co
```

2. 启动 simple-proxy

3. 在浏览器访问 `http://webmail.prod.code27.cn:8080/`

### 场景 2: 配合 Nginx 使用

如果你想去掉端口号，可以在本地运行 Nginx：

**nginx.conf 配置：**
```nginx
server {
    listen 80;
    server_name webmail.prod.code27.cn xxx.code27.cn yyy.code27.co;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

这样就可以直接访问 `http://webmail.prod.code27.cn/`

### 场景 3: Docker 部署

```bash
# 1. 复制配置
cp .env.example .env

# 2. 编辑 .env，设置代理
vim .env

# 3. 启动
docker-compose up -d

# 4. 查看日志
docker-compose logs -f
```

### 场景 4: API 调用

如果你的应用需要调用这些域名的 API：

```python
# Python 示例
import requests

response = requests.get(
    'http://localhost:8080/api/endpoint',
    headers={'Host': 'webmail.prod.code27.cn'}
)
print(response.text)
```

```javascript
// Node.js 示例
const axios = require('axios');

axios.get('http://localhost:8080/api/endpoint', {
    headers: {
        'Host': 'webmail.prod.code27.cn'
    }
}).then(response => {
    console.log(response.data);
});
```

## 配置说明

### 环境变量

| 变量 | 说明 | 默认值 | 示例 |
|------|------|--------|------|
| `UPSTREAM_HOST` | 上游真实 IP | `47.252.16.154` | `47.252.16.154` |
| `LISTEN_PORT` | 监听端口 | `8080` | `8080` |
| `HTTP_PROXY` | HTTP 代理 | - | `http://127.0.0.1:7890` |
| `HTTPS_PROXY` | HTTPS 代理 | - | `http://127.0.0.1:7890` |
| `SOCKS_PROXY` | SOCKS5 代理 | - | `socks5://127.0.0.1:1080` |

### 代理优先级

程序会按以下顺序选择代理：
1. `SOCKS_PROXY`（最高优先级）
2. `HTTP_PROXY` / `HTTPS_PROXY`
3. 不使用代理（不推荐，可能无法访问）

### 常见代理地址

| 代理工具 | 默认地址 |
|---------|---------|
| Clash | `http://127.0.0.1:7890` |
| V2rayN | `socks5://127.0.0.1:1080` 或 `http://127.0.0.1:10809` |
| Shadowsocks | `socks5://127.0.0.1:1080` |
| Qv2ray | `socks5://127.0.0.1:1080` 或 `http://127.0.0.1:8889` |

## 故障排查

### 问题 1: 连接被拒绝

**症状：**
```
代理请求失败: dial tcp 47.252.16.154:80: connect: connection refused
```

**解决方案：**
- 检查 `UPSTREAM_HOST` 是否正确
- 检查目标服务器是否在线
- 确认代理是否正常工作

### 问题 2: 代理连接失败

**症状：**
```
代理请求失败: socks connect tcp 47.252.16.154:80: dial tcp 127.0.0.1:1080: connect: connection refused
```

**解决方案：**
- 检查代理服务是否启动
- 验证代理地址和端口是否正确
- 尝试手动测试代理：
  ```bash
  # 测试 HTTP 代理
  curl -x http://127.0.0.1:7890 http://www.google.com
  
  # 测试 SOCKS5 代理
  curl -x socks5://127.0.0.1:1080 http://www.google.com
  ```

### 问题 3: Host 头不匹配

**症状：**
服务器返回 404 或错误的页面

**解决方案：**
- 确保使用了正确的 Host 头
- 查看日志确认 Host 头是否正确传递：
  ```
  转发请求到: http://47.252.16.154/ (Host头: webmail.prod.code27.cn)
  ```

### 问题 4: Docker 无法访问宿主机代理

**症状：**
Docker 容器内无法连接到 `127.0.0.1:7890`

**解决方案：**
- 将代理地址改为 `host.docker.internal:7890`
- 或者使用 `network_mode: host`（仅 Linux）
- 或者找到宿主机的 IP 地址使用

示例：
```bash
docker run -d \
  -p 8080:8080 \
  -e UPSTREAM_HOST=47.252.16.154 \
  -e HTTP_PROXY=http://host.docker.internal:7890 \
  simple-proxy
```

### 问题 5: 查看详细日志

程序会输出详细的请求日志：

```
2024/01/01 12:00:00 代理服务器启动在 :8080
2024/01/01 12:00:00 上游服务器: 47.252.16.154
2024/01/01 12:00:00 HTTP代理: http://127.0.0.1:7890
2024/01/01 12:00:01 使用 HTTP/HTTPS 代理
2024/01/01 12:00:02 收到请求: GET / (Host: webmail.prod.code27.cn)
2024/01/01 12:00:02 转发请求到: http://47.252.16.154/ (Host头: webmail.prod.code27.cn)
2024/01/01 12:00:03 请求完成: GET / -> 200 (1234 bytes)
```

## 性能优化

### 调整连接池

编辑 `main.go` 中的 `createHTTPClient` 函数：

```go
transport := &http.Transport{
    MaxIdleConns:        100,  // 增加最大空闲连接数
    MaxIdleConnsPerHost: 20,   // 增加每个主机的空闲连接数
    IdleConnTimeout:     90 * time.Second,
}
```

### 生产环境建议

1. 使用反向代理（Nginx/Caddy）
2. 启用 HTTPS（通过 Nginx）
3. 配置日志轮转
4. 监控和告警

## 安全注意事项

1. **不要暴露到公网**：这个代理应该只在本地或内网使用
2. **使用 HTTPS**：如果必须远程访问，请配置 SSL/TLS
3. **访问控制**：考虑添加认证机制
4. **日志审计**：定期检查访问日志

## 高级用法

### 自定义端口

```bash
export LISTEN_PORT=3000
./simple-proxy
```

### 使用不同的上游服务器

```bash
export UPSTREAM_HOST=123.45.67.89
./simple-proxy
```

### 多个域名对应同一个 IP

这个代理支持任意域名，只要设置正确的 Host 头即可：

```bash
curl -H "Host: domain1.com" http://localhost:8080/
curl -H "Host: domain2.com" http://localhost:8080/
curl -H "Host: domain3.com" http://localhost:8080/
```

所有请求都会被转发到同一个 `UPSTREAM_HOST`，但保持不同的 Host 头。

## 总结

这个代理的核心功能是：
1. **接收请求**：监听本地端口（默认 8080）
2. **保持 Host 头**：维持原始域名信息
3. **修改目标**：将请求发送到固定 IP
4. **通过代理**：所有请求通过你配置的代理转发

相当于实现了 `curl -H "Host: xxx.com" http://IP --proxy http://proxy-addr` 的功能！



